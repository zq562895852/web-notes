/**
 * webpack打包优化
 */

/**
 *  network
 *   Queueing请求排队的时间。关于这个，需要知道一个背景，就是浏览器与同一个域名建立的TCP连接数是有限制的，chrome设置的6个，如果说同一时间，发起的同一域名的请求超过了6个，这时候就需要排队了，也就是这个Queueing时间

    Stalled是浏览器得到要发出这个请求的指令，到请求可以发出的等待时间，一般是代理协商、以及等待可复用的TCP连接释放的时间，不包括DNS查询、建立TCP连接等时间等
    DNS Lookup DNS查询的时间，页面内任何新的域名都需要走一遍 完整的DNS查询过程，已经查询过的则走缓存
    Initial Connection / Connecting 建立TCP连接的时间，包括TCP的三次握手和SSL的认证
    SSL完成ssl认证的时间
    Request sent/sending请求第一个字节发出前到最后一个字节发出后的时间，也就是上传时间
    Waiting 请求发出后，到收到响应的第一个字节所花费的时间(Time To First Byte)
    Content Download 收到响应的第一个字节，到接受完最后一个字节的时间，就是下载时间
 */

/**
  * chrome 工具
  * （一）最先是页面右上方的小黑窗：其实提示已经说的很清楚了，它显示的就是我们的GPU占用率，能够让我们清楚地知道页面是否发生了大量的重绘。
    （二）Layers版块：这就是用于显示我们刚提到的DOM渲染层的工具了，左侧的列表里将会列出页面里存在哪些渲染层，还有这些渲染层的详细信息。
    （三）Rendering版块：这个版块和我们的控制台在同一个地方，大家可别找不到它。前三个勾选项是我们最常使用的，让我来给大家解释一下他们的功能（充当一次免费翻译）
        ①Paint flashing：勾选之后会对页面中发生重绘的元素高亮显示
        ②Layer borders：和我们的Layer版块功能类似，它会用高亮边界突出我们页面中的各个渲染层
        ③FPS meter：就是开启我们在（一）中提到的小黑窗，用于观察我们的GPU占用率

    优化思路：发生重绘重拍可以使用一个单独的渲染层，这样就不会触发其他元素的重绘了，那什么情况下会触发渲染层？
     video元素、WebGL、Canvas、CSS3 3D、CSS滤镜、z-index大于某个相邻节点的元素都会触发新的Layer
        transform: translateZ(0);
        backface-visibility: hidden; 这样就可以触发新的渲染层

    可以查看引发重排和重绘的属性：https://csstriggers.com/

   html和css一般优化
    （一）CSS属性读写分离：浏览器没次对元素样式进行读操作时，都必须进行一次重新渲染（重排 + 重绘），所以我们在使用JS对元素样式进行读写操作时，最好将两者分离开，先读后写，避免出现两者交叉使用的情况。最最最客观的解决方案，就是不用JS去操作元素样式，这也是我最推荐的。
    （二）通过切换class或者style.csstext属性去批量操作元素样式
    （三）DOM元素离线更新：当对DOM进行相关操作时，例如innerHTML、appendChild等都可以使用Document Fragment对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作。
    （四）将没用的元素设为不可见：visibility: hidden，这样可以减小重绘的压力，必要的时候再将元素显示。
    （五）压缩DOM的深度，一个渲染层内不要有过深的子元素，少用DOM完成页面样式，多使用伪元素或者box-shadow取代。
    （六）图片在渲染前指定大小：因为img元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流。
    （七）对页面中可能发生大量重排重绘的元素单独触发渲染层，使用GPU分担CPU压力。（这项策略需要慎用，得着重考量以牺牲GPU占用率能否换来可期的性能优化，毕竟页面中存在太多的渲染层对与GPU而言也是一种不必要的压力，通常情况下，我们会对动画元素采取硬件加速。）
  */

/**
 * 浏览器加载资源过程：
 *    首先会将所有需要加载的资源进行分类
 *    然后根据浏览器相关的安全策略，来决定资源的加载权限
 *    资源的优先级计算排序
 *    根据加载优先级加载资源
 *
 * 安全协议，可以使http强制转换成https,当然需要服务器支持
 * <meta http-equiv="Content-Secur****ity-Policy" content="upgrade-insecure-requests">
 * 对于安全性要求极高的网站，可以使用下面的方式阻止所有类型的非安全链接请求
 * <meta http-equiv="Content-Security-Policy" content="block-all-mixed-content">
 * 浏览器会提前加载preload
 * <link rel="preload" href="test.jpg">
 * 
 * 
 *  资源预加载：<link rel="prefetch" href="test.css">
    DNS预解析：<link rel="dns-prefetch" href="//haitao.nos.netease.com">
    http预连接：<link rel="prefetch" href="//www.kaola.com"> 将建立对该域名的TCP链接
    页面预渲染：<link rel="prerender" href="//m.kaola.com"> 将会预先加载链接文档的所有资源

    preload来告诉浏览器预先请求当前页需要的资源，从而提高这些资源的请求优先级
     Prefetch来告诉浏览器用户将来可能在其他页面（非本页面）可能使用到的资源，那么浏览器会在空闲时，就去预先加载这些资源放在http缓存内，最常见的dns-prefetch


 * 浏览器内核资源加载优先级
 *   html、css、font这三种类型的资源优先级最高；
     然后是preload资源（通过<link rel=“preload">标签预加载）、script、xhr请求；
     接着是图片、语音、视频；
     最低的是prefetch预读取的资源

    对于XHR请求资源：将同步XHR请求的优先级调整为最高。
    XHR请求可以分为同步请求和异步请求，浏览器会把同步请求的优先级提升到最高级，以便尽早获取数据、加快页面的显示。
    对于图片资源：会根据图片是否在可见视图之内来改变优先级。
    图片资源的默认优先级为Low。现代浏览器为了提高用户首屏的体验，在渲染时会计算图片资源是否在首屏可见视图之内，在的话，会将这部分视口可见图片(Image in viewport)资源的优先级提升为High。
    对于脚本资源：浏览器会将根据脚本所处的位置和属性标签分为三类，分别设置优先级。
    首先，对于添加了defer/async属性标签的脚本的优先级会全部降为Low。
    然后，对于没有添加该属性的脚本，根据该脚本在文档中的位置是在浏览器展示的第一张图片之前还是之后，又可分为两类。在之前的(标记early**)它会被定为High优先级，在之后的(标记late**)会被设置为Medium优先级。
    下图总结了资源优先级计算后各类资源的优先级情况，其中特别将上面讲的三种常见资源的情况框了出来。红框框中的为脚本类型、紫框的为图片类型、蓝框为XHR请求
    
    关键请求链（Critical-Request-Chains）的概念。可视区域渲染完毕（首屏），并对于用户来说可用时，必须加载的资源请求队列，就叫做关键请求链


    LightHouse 插件，可以生成报告，包含了有关该页面性能的全方面报告和建议
 */
