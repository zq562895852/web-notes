/**
 * 引用计数：给一个变量赋值引用类型，则该对象的引用次数+1，如果这个变量变成了其他值，那么该对象的引用次数-1，垃圾回收器会回收引用次数为0的对象。但是当对象循环引用时，会导致引用次数永远无法归零，造成内存无法释放。
 *
 * 标记清除：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的等待回收的对象。
 *
 * V8的垃圾回收：
 *    JS引擎中对变量的存储主要有两种位置，栈内存和堆内存，栈内存存储基本类型数据以及引用类型数据的内存地址，堆内存储存引用类型的数据
 *    栈内存回收： 栈内存调用栈上下文切换后就被回收，比较简单
 *    堆内存回收： 
 *      V8的堆内存分为新生代内存和老生代内存，新生代内存是临时分配的内存，存在时间短，老生代内存存在时间长
 *      新生代内存回收机制：

        新生代内存容量小，64位系统下仅有32M。新生代内存分为From、To两部分，进行垃圾回收时，先扫描From，将非存活对象回收，将存活对象顺序复制到To中，之后调换From/To，等待下一次回收


        老生代内存回收机制

        晋升：如果新生代的变量经过多次回收依然存在，那么就会被放入老生代内存中
        标记清除：老生代内存会先遍历所有对象并打上标记，然后对正在使用或被强引用的对象取消标记，回收被标记的对象
        整理内存碎片：把对象挪到内存的一端

 */

/**
  * 回收堆空间
    V8 中把堆分成新生代与老生代两个区域：

    新生代：用来存放生存周期较短的小对象，一般只支持1～8M的容量
    老生代：用来存放生存周期较长的对象或大对象

    V8 对这两块使用了不同的回收器：

    新生代使用副垃圾回收器
    老生代使用主垃圾回收器

    其实无论哪种垃圾回收器，都采用了同样的流程（三步走）：

    标记： 标记堆空间中的活动对象（正在使用）与非活动对象（可回收）
    垃圾清理： 回收非活动对象所占用的内存空间
    内存整理： 当进行频繁的垃圾回收时，内存中可能存在大量不连续的内存碎片，当需要分配一个需要占用较大连续内存空间的对象时，可能存在内存不足的现象，所以，这时就需要整理这些内存碎片。

    副垃圾回收器与主垃圾回收器虽然都采用同样的流程，但使用的回收策略与算法是不同的。
    副垃圾回收器
    它采用 Scavenge 算法及对象晋升策略来进行垃圾回收
    所谓 Scavenge 算法，即把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：
    新加入的对象都加入对象区域，当对象区满的时候，就执行一次垃圾回收，执行流程如下：

    标记：首先要对区域内的对象进行标记（活动对象、非活动对象）
    垃圾清理：然后进行垃圾清理：将对象区的活动对象复制到空闲区域，并进行有序的排列，当复制完成后，对象区域与空闲区域进行翻转，空闲区域晋升为对象区域，对象区域为空闲区域

    翻转后，对象区域是没有碎片的，此时不需要进行第三步（内存整理了）

    但，新生代区域很小的，一般1～8M的容量，所以它很容易满，所以，JavaScript 引擎采用对象晋升策略来处理，即只要对象经过两次垃圾回收之后依然继续存活，就会被晋升到老生代区域中。
    主垃圾回收器
    老生代区域里除了存在从新生代晋升来的存活时间久的对象，当遇到大对象时，大对象也会直接分配到老生代。
    所以主垃圾回收器主要保存存活久的或占用空间大的对象，此时采用 Scavenge 算法就不合适了。V8 中主垃圾回收器主要采用标记-清除法进行垃圾回收。
    主要流程如下：

    标记：遍历调用栈，看老生代区域堆中的对象是否被引用，被引用的对象标记为活动对象，没有被引用的对象（待清理）标记为垃圾数据。
    垃圾清理：将所有垃圾数据清理掉
    内存整理：标记-整理策略，将活动对象整理到一起

    增量标记
    V8 浏览器会自动执行垃圾回收，但由于 JavaScript 也是运行在主线程上的，一旦执行垃圾回收，就要打断 JavaScript 的运行，可能会或多或少的造成页面的卡顿，影响用户体验，所以 V8 决定采用增量 标记算法回收：
    即把垃圾回收拆成一个个小任务，穿插在 JavaScript 中执行。

  */
