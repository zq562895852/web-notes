###执行上下文
1. 什么是执行上下文-> 代码在运行的时候的执行环境
2. 执行上下文的类型
 - 全局执行上下文
   + 不在函数内部执行的代码，全局上下文会创建一个全局window对象，并且设置this的指向，在严格模式下this指向undefined
 - 函数执行上下文
   + 每当一个函数被调用是，都会给该函数创建一个新的上下文，每个函数都有他自己的执行上下文
 - Eval函数执行上下文
   + 执行eval函数内部的代码会有属于他自己的上下文
 3. 执行栈
  + 函数调用栈，是一种先进先出的数据结构的栈，用来存储代码运行是创建的执行上下文
 4. 如何创建执行上下文
  + 创建执行上下文有两个阶段-> 创建阶段-执行阶段
  + 在创建阶段会 this值的决定，创建此法环境，创建变量环境
  `ExecutionContext = {
      ThisBinding = <this value>,
      LexicalEnvironment = { ... },
      VariableEnvironment = { ... },
    }`
  + 词法环境 简单来说词法环境是一种持有标识符—变量映射的结构
    词法环境的内部有两部分，环境记录器，一个外部环境引用
    - 环境记录器是存储变量和函数声明的实际位置
    - 外部环境的引用意味着他可以访问其父级词法环境
  + 词法环境的两种类型
   - 全局环境 没有外部环境引用的词法环境，全局环境的外部环境引用是null，拥有内建的对象如：Date Object Arrary等
   - 函数环境 函数内部定义的变量存储在环境记录器中，并且引用的外部环境可能是全局环境，也可能是包含此函数的外部函数
  + 环境记录器也有两种
   - 声明式环境记录器存储变量，函数和参数
   - 对象环境记录器 定义全局上下文中的变量和函数的关系
    在全局环境中，环境记录器是对象环境记录器，在函数环境中，环境记录器是声明是环境记录器
   + 变量环境
     - 它同样是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。
     - 在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 undefined（var 情况下），或者未初始化（let 和 const 情况下）。
     
 4. 执行阶段
   - 在此阶段完成所有变量的分配最后执行
   - 注意 — 在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 let 变量的值，它会被赋值为 undefined
   
  + JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。
  这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？
  就三种，全局代码、函数代码、eval代码。
  + javaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext
 5. 静态作用域和动态作用域
  - 词法作用域属于静态作用域，函数的作用域在函数定义的时候就确定了，动态作用域是在函数调用的时候才决定的，所以JavaScript函数作用域是根据定义的地方决定的而不是调用的地方
 