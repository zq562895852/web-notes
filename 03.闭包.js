/**
 * 作用域链：
 * 1.当代码运行时，需要一定的空间保存本地变量，这个空间成为作用域对象，作用域对象是在堆中被创建的，所以函数返回后依然可以访问，
 * 在作用域链的最顶层就是全局对象（Global Object），运行在全局环境的代码，作用域链始终只有一个全局对象，所以全局定义的变量就会挂载到全局对象中，当函数被调用的时候，作用域链就会包含多个作用域对象
 *
 * 2. 当一个函数被定义的时候，函数的标识符就被加到了当前的作用域对象，这个标识符所引用的是一个函数对象，函数对象中包含很多属性吗，其中有一个内部属性[[scope]],这个属性指向就是当前作用域，也就是创建的时候，我们能够直接访问的那个作用域对象  “直接访问”的意思就是，在当前作用域链中，该作用域对象处于最底层，没有子作用域对象。
 *
 * 3. 当一个函数调用的时候，一个新的作用域对象被创建（一个作用域的创建是函数调用之后才会存在？？？）所以才会产生函数作用域，这个新的作用域对象包函数所定义的本地变量，以及参数（arguments）,这个新的作用域对象运行在创建函数时的那个作用域，
 *
 * 4. 很重要的是这些作用域对象依然被引用，他们就不会被垃圾回收器销毁，就一直可以访问，当引用一个作用域对象的最后一个引用被解除的时候，并不会立即回收，只是现在可以回收了
 *
 * 5. 当函数调用完毕时，再也没有引用的函数（所有）作用域对象就变回了调用前的关系，也就是函数定义的时候，标识符指向的函数对象，
 *
 * 6. 需要注意的是：作用域链是不会复制的，每次函数调用只会往作用域链下面新增一个作用域对象，所以，如果在函数调用的过程当中对作用域链中的任何一个作用域对象的变量进行修改的话，那么同时作用域链中也拥有该作用域对象的函数对象也是能够访问到这个变化后的变量的。
 *
 * 7. this的值不会被保存在作用域链中，this的值取决于函数被调用的时候的情景。
 *
 *什么是闭包？闭包就是同时含有对函数对象以及作用域对象引用的对象。实际上，所有JavaScript对象都是闭包。
闭包是什么时候被创建的？因为所有JavaScript对象都是闭包，因此，当你定义一个函数的时候，你就定义了一个闭包。
闭包是什么时候被销毁的？当它不被任何其他的对象引用的时候。
 *
 */

//  闭包的使用

for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(new Date(), i);
  }, 1000);
}
console.log(new Date(), i);

// 初级
for (var i = 0; i < 5; i++) {
  (function(j) {
    // j = i
    setTimeout(function() {
      console.log(new Date(), j);
    }, 1000);
  })(i);
}

console.log(new Date(), i);

// 希望  0 -> 1 -> 2 -> 3 -> 4 -> 5  循环结束隔5s输出5
for (var i = 0; i < 5; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(new Date(), j);
    }, 1000 * j); // 这里修改 0~4 的定时器时间
  })(i);
}

setTimeout(function() {
  // 这里增加定时器，超时设置为 5 秒
  console.log(new Date(), i);
}, 1000 * i);

// 中级
const tasks = [];
for (var i = 0; i < 5; i++) {
  // 这里 i 的声明不能改成 let，如果要改该怎么做？
  (j => {
    tasks.push(
      new Promise(resolve => {
        setTimeout(() => {
          console.log(new Date(), j);
          resolve(); // 这里一定要 resolve，否则代码不会按预期 work
        }, 1000 * j); // 定时器的超时时间逐步增加
      })
    );
  })(i);
}

Promise.all(tasks).then(() => {
  setTimeout(() => {
    console.log(new Date(), i);
  }, 1000); // 注意这里只需要把超时设置为 1 秒
});

// 高级
const sleep = timeountMS =>
  new Promise(resolve => {
    setTimeout(resolve, timeountMS);
  });

(async () => {
  // 声明即执行的 async 函数表达式
  for (var i = 0; i < 5; i++) {
    if (i > 0) {
      // 这种是阻塞式的，也就是必须等待await执行完才会执行下一个
      await sleep(1000);
    }
    console.log(new Date(), i);
  }

  await sleep(1000);
  console.log(new Date(), i);
})();
